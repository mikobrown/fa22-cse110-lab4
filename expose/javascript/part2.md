1. Line 12 will print "3".
2. Line 13 will print "150".
3. Line 14 will print "150".
4. The function will return the list [50, 100, 150]. The function goes through the prices list, and because discount is 0.5, cuts the value of each element in half and returns new list of halved numbers.
5. The code will cause an error because the variable i is declared as let variable in scope of the for loop, so it is undeclared at line 12.
6. The code will cause an error because the variable discountedPrice is declared as let variable in scope of the for loop, so it is undeclared at line 13.
7. Line 14 will print "150".
8. The function will return the list [50, 100, 150]. The function goes through the prices list, and because discount is 0.5, cuts the value of each element in half and returns new list of halved numbers.
9. The code will cause an error because the variable i is declared as let variable in scope of the for loop, so it is undeclared at line 11.
10. Line 12 will print "3".
11. The function will return the list [50, 100, 150]. The function goes through the prices list, and because discount is 0.5, cuts the value of each element in half and returns new list of halved numbers.
12.
    A. student["name"]  
    B. student["Grad Year"]  
    C. student["greeting"]()  
    D. student["Favorite Teacher"]["name"]  
    E. student["courseLoad"][0]  
13. 
    A. '32' - integer maps to string  
    B. 1 - string maps to integer  
    C. 3 - null maps to integer 0  
    D. '3null' - null maps to string  
    E. 4 - true maps to integer 1  
    F. 0 - false and null map to integer 0  
    G. '3undefined' - undefined maps to string  
    H. NaN - 3 maps to integer and undefined cannot map to integer, so get NaN output  
14. 
    A. true - string maps to integer  
    B. false - string comparison '2' is greater than '1'  
    C. true - values are equal ignoring type  
    D. false - values types are not equal  
    E. false - true is mapped to integer 1  
    F. true - Boolean(2) is true so values are equal  
15. == checks for equality after type conversions, === checks for equality without type conversions, requiring both sides to have same type
16. Check part2-question16.js
17. The returned result will be [2, 4, 6]. This is because the modifyArray function performs the callback on each element of the array, returns new array with the modified elements. The callback function, doSomething just doubles the value of the input so the overall result is the array values are doubled.
18. Check part2-question18.js
19. 1  
    4  
    3  
    2
